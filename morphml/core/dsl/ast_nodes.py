"""Abstract Syntax Tree node definitions for MorphML DSL.

Defines the structure of the AST generated by the parser.

Author: Eshan Roy <eshanized@proton.me>
Organization: TONMOY INFRASTRUCTURE & VISION
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

from morphml.core.dsl.syntax import LAYER_TYPES, EVOLUTION_STRATEGIES
from morphml.exceptions import ValidationError


@dataclass(frozen=True)
class ASTNode:
    """
    Base class for all AST nodes.

    Uses visitor pattern for traversal and transformation.
    Immutable to prevent accidental modification during compilation.
    """

    def accept(self, visitor: "ASTVisitor") -> Any:
        """
        Visitor pattern support for AST traversal.

        Args:
            visitor: Visitor instance

        Returns:
            Result from visitor

        Raises:
            NotImplementedError: If subclass doesn't implement
        """
        raise NotImplementedError(f"{self.__class__.__name__} must implement accept()")


@dataclass(frozen=True)
class ParamNode(ASTNode):
    """
    Represents a hyperparameter specification.

    Can represent:
    - Single value: filters=32
    - List of values: filters=[32, 64, 128]
    - Range: units=(64, 512)

    Attributes:
        name: Parameter name
        values: List of possible values
        param_type: Type ('categorical', 'integer', 'float', 'boolean')
    """

    name: str
    values: List[Any]
    param_type: Optional[str] = None

    def __post_init__(self) -> None:
        """Validate and infer parameter type."""
        if not self.values:
            raise ValidationError(f"Parameter '{self.name}' has no values")

        # Infer type if not specified
        if self.param_type is None:
            object.__setattr__(self, "param_type", self._infer_type())

    def _infer_type(self) -> str:
        """Infer parameter type from values."""
        if len(self.values) == 1:
            value = self.values[0]
            if isinstance(value, bool):
                return "boolean"
            elif isinstance(value, int):
                return "integer"
            elif isinstance(value, float):
                return "float"
            elif isinstance(value, str):
                return "categorical"
        else:
            # Multiple values - check consistency
            if all(isinstance(v, bool) for v in self.values):
                return "boolean"
            elif all(isinstance(v, int) for v in self.values):
                return "integer"
            elif all(isinstance(v, (int, float)) for v in self.values):
                return "float"
            else:
                return "categorical"

        return "categorical"

    def accept(self, visitor: "ASTVisitor") -> Any:
        """Accept visitor."""
        return visitor.visit_param(self)

    def __repr__(self) -> str:
        """Readable representation."""
        return f"ParamNode({self.name}={self.values})"


@dataclass(frozen=True)
class LayerNode(ASTNode):
    """
    Represents a layer specification in the search space.

    Attributes:
        layer_type: Type of layer ('conv2d', 'dense', etc.)
        params: Dictionary of parameter specifications
        metadata: Additional metadata

    Example:
        LayerNode('conv2d', {'filters': ParamNode('filters', [32, 64])})
    """

    layer_type: str
    params: Dict[str, ParamNode] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Validate layer type."""
        if self.layer_type not in LAYER_TYPES:
            raise ValidationError(
                f"Unknown layer type: '{self.layer_type}'. "
                f"Valid types: {', '.join(LAYER_TYPES)}"
            )

    def accept(self, visitor: "ASTVisitor") -> Any:
        """Accept visitor."""
        return visitor.visit_layer(self)

    def get_param(self, name: str, default: Any = None) -> Optional[ParamNode]:
        """Get parameter by name."""
        return self.params.get(name, default)

    def __repr__(self) -> str:
        """Readable representation."""
        param_strs = [f"{k}={v.values}" for k, v in self.params.items()]
        return f"Layer.{self.layer_type}({', '.join(param_strs)})"


@dataclass(frozen=True)
class SearchSpaceNode(ASTNode):
    """
    Represents a complete search space definition.

    Attributes:
        layers: List of layer specifications
        global_params: Global parameters (optimizer, LR, etc.)
        name: Optional name for the search space
        metadata: Additional metadata
    """

    layers: List[LayerNode]
    global_params: Dict[str, ParamNode] = field(default_factory=dict)
    name: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Validate search space."""
        if not self.layers:
            raise ValidationError("SearchSpace must contain at least one layer")

    def accept(self, visitor: "ASTVisitor") -> Any:
        """Accept visitor."""
        return visitor.visit_search_space(self)

    def __repr__(self) -> str:
        """Readable representation."""
        return (
            f"SearchSpace(name={self.name}, "
            f"layers={len(self.layers)}, "
            f"params={list(self.global_params.keys())})"
        )


@dataclass(frozen=True)
class EvolutionNode(ASTNode):
    """
    Represents evolution/optimization configuration.

    Attributes:
        strategy: Evolution strategy ('genetic', 'bayesian', etc.)
        params: Strategy parameters
        metadata: Additional metadata
    """

    strategy: str
    params: Dict[str, Any] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self) -> None:
        """Validate evolution strategy."""
        if self.strategy not in EVOLUTION_STRATEGIES:
            raise ValidationError(
                f"Unknown evolution strategy: '{self.strategy}'. "
                f"Valid strategies: {', '.join(EVOLUTION_STRATEGIES)}"
            )

    def accept(self, visitor: "ASTVisitor") -> Any:
        """Accept visitor."""
        return visitor.visit_evolution(self)

    def get_param(self, name: str, default: Any = None) -> Any:
        """Get parameter by name."""
        return self.params.get(name, default)

    def __repr__(self) -> str:
        """Readable representation."""
        return f"Evolution(strategy={self.strategy}, params={list(self.params.keys())})"


@dataclass(frozen=True)
class ConstraintNode(ASTNode):
    """
    Represents a constraint on the search space.

    Attributes:
        constraint_type: Type of constraint ('max_depth', 'max_params', etc.)
        params: Constraint parameters
    """

    constraint_type: str
    params: Dict[str, Any] = field(default_factory=dict)

    def accept(self, visitor: "ASTVisitor") -> Any:
        """Accept visitor."""
        return visitor.visit_constraint(self)

    def __repr__(self) -> str:
        """Readable representation."""
        return f"Constraint({self.constraint_type}, {self.params})"


@dataclass(frozen=True)
class ExperimentNode(ASTNode):
    """
    Root node representing a complete experiment definition.

    Attributes:
        search_space: Search space specification
        evolution: Evolution configuration
        objectives: List of objectives to optimize
        constraints: List of constraints
        metadata: Additional metadata
    """

    search_space: SearchSpaceNode
    evolution: Optional[EvolutionNode] = None
    objectives: List[str] = field(default_factory=list)
    constraints: List[ConstraintNode] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def accept(self, visitor: "ASTVisitor") -> Any:
        """Accept visitor."""
        return visitor.visit_experiment(self)

    def __repr__(self) -> str:
        """Readable representation."""
        return (
            f"Experiment(\n"
            f"  search_space={self.search_space},\n"
            f"  evolution={self.evolution},\n"
            f"  objectives={self.objectives}\n"
            f")"
        )


# Visitor interface for AST traversal
class ASTVisitor:
    """
    Base class for AST visitors.

    Implements the visitor pattern for traversing and transforming AST.
    Subclass this to implement custom operations on the AST.

    Example:
        class PrintVisitor(ASTVisitor):
            def visit_layer(self, node: LayerNode):
                print(f"Layer: {node.layer_type}")
    """

    def visit_param(self, node: ParamNode) -> Any:
        """Visit ParamNode."""
        pass

    def visit_layer(self, node: LayerNode) -> Any:
        """Visit LayerNode."""
        for param in node.params.values():
            param.accept(self)

    def visit_search_space(self, node: SearchSpaceNode) -> Any:
        """Visit SearchSpaceNode."""
        for layer in node.layers:
            layer.accept(self)
        for param in node.global_params.values():
            param.accept(self)

    def visit_evolution(self, node: EvolutionNode) -> Any:
        """Visit EvolutionNode."""
        pass

    def visit_constraint(self, node: ConstraintNode) -> Any:
        """Visit ConstraintNode."""
        pass

    def visit_experiment(self, node: ExperimentNode) -> Any:
        """Visit ExperimentNode."""
        node.search_space.accept(self)
        if node.evolution:
            node.evolution.accept(self)
        for constraint in node.constraints:
            constraint.accept(self)


# Helper functions for AST manipulation
def walk_ast(node: ASTNode, callback: callable) -> None:
    """
    Walk the AST and call callback for each node.

    Args:
        node: Root node to start from
        callback: Function to call with each node
    """

    class WalkVisitor(ASTVisitor):
        def visit_param(self, n: ParamNode) -> None:
            callback(n)

        def visit_layer(self, n: LayerNode) -> None:
            callback(n)
            super().visit_layer(n)

        def visit_search_space(self, n: SearchSpaceNode) -> None:
            callback(n)
            super().visit_search_space(n)

        def visit_evolution(self, n: EvolutionNode) -> None:
            callback(n)

        def visit_constraint(self, n: ConstraintNode) -> None:
            callback(n)

        def visit_experiment(self, n: ExperimentNode) -> None:
            callback(n)
            super().visit_experiment(n)

    visitor = WalkVisitor()
    node.accept(visitor)


def count_layers(ast: ASTNode) -> int:
    """Count number of layers in AST."""
    count = 0

    def counter(node: ASTNode) -> None:
        nonlocal count
        if isinstance(node, LayerNode):
            count += 1

    walk_ast(ast, counter)
    return count
